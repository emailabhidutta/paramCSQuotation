import { AfterViewInit, ChangeDetectorRef, ElementRef, OnDestroy, OnInit, Renderer2, TemplateRef, ViewContainerRef } from '@angular/core';
import { Options } from '@popperjs/core';
import { Triggers } from '../coreui.types';
import { IntersectionService, ListenersService } from '../services';
import { ElementRefDirective } from '../shared';
import * as i0 from "@angular/core";
export declare class PopoverDirective implements OnDestroy, OnInit, AfterViewInit {
    #private;
    private renderer;
    private hostElement;
    private viewContainerRef;
    private listenersService;
    private changeDetectorRef;
    private intersectionService;
    /**
     * Content of popover
     * @type {string | TemplateRef}
     */
    readonly content: import("@angular/core").InputSignal<string | TemplateRef<any> | undefined>;
    contentEffect: import("@angular/core").EffectRef;
    /**
     * Optional popper Options object, takes precedence over cPopoverPlacement prop
     * @type Partial<Options>
     */
    readonly popperOptions: import("@angular/core").InputSignal<Partial<Options>>;
    popperOptionsEffect: import("@angular/core").EffectRef;
    popperOptionsComputed: import("@angular/core").Signal<{
        placement: import("@popperjs/core").Placement;
        modifiers?: Partial<import("@popperjs/core").Modifier<any, any>>[] | undefined;
        strategy?: import("@popperjs/core").PositioningStrategy | undefined;
        onFirstUpdate?: ((arg0: Partial<import("@popperjs/core").State>) => void) | undefined;
    }>;
    /**
     * Describes the placement of your component after Popper.js has applied all the modifiers that may have flipped or altered the originally provided placement property.
     * @type: 'top' | 'bottom' | 'left' | 'right'
     * @default: 'top'
     */
    readonly placement: import("@angular/core").InputSignal<"top" | "bottom" | "right" | "left">;
    /**
     * ElementRefDirective for positioning the tooltip on reference element
     * @type: ElementRefDirective
     * @default: undefined
     */
    readonly reference: import("@angular/core").InputSignal<ElementRefDirective | undefined>;
    readonly referenceRef: import("@angular/core").Signal<ElementRef<any>>;
    /**
     * Sets which event handlers you’d like provided to your toggle prop. You can specify one trigger or an array of them.
     * @type: 'Triggers | Triggers[]
     */
    readonly trigger: import("@angular/core").InputSignal<Triggers | Triggers[]>;
    /**
     * Toggle the visibility of popover component.
     * @type boolean
     */
    readonly visible: import("@angular/core").ModelSignal<boolean>;
    visibleEffect: import("@angular/core").EffectRef;
    get ariaDescribedBy(): string | null;
    private tooltip;
    private tooltipId;
    private tooltipRef;
    private popperInstance;
    private _popperOptions;
    constructor(renderer: Renderer2, hostElement: ElementRef, viewContainerRef: ViewContainerRef, listenersService: ListenersService, changeDetectorRef: ChangeDetectorRef, intersectionService: IntersectionService);
    ngAfterViewInit(): void;
    ngOnDestroy(): void;
    ngOnInit(): void;
    private setListeners;
    private clearListeners;
    private intersectionServiceSubscribe;
    private getUID;
    private createTooltipElement;
    private destroyTooltipElement;
    private addTooltipElement;
    private removeTooltipElement;
    static ɵfac: i0.ɵɵFactoryDeclaration<PopoverDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<PopoverDirective, "[cPopover]", ["cPopover"], { "content": { "alias": "cPopover"; "required": false; "isSignal": true; }; "popperOptions": { "alias": "cPopoverOptions"; "required": false; "isSignal": true; }; "placement": { "alias": "cPopoverPlacement"; "required": false; "isSignal": true; }; "reference": { "alias": "cTooltipRef"; "required": false; "isSignal": true; }; "trigger": { "alias": "cPopoverTrigger"; "required": false; "isSignal": true; }; "visible": { "alias": "cPopoverVisible"; "required": false; "isSignal": true; }; }, { "visible": "cPopoverVisibleChange"; }, never, never, true, never>;
}
